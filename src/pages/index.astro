---
import "../styles/global.css";
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Seek Legal | Interactive</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div class="stage" id="stage">
      <div class="vignette"></div>

      <div class="hero">
        <h1>
          <span style="color: #eaddf7;">Seek</span>
          <span style="color: #ffffff;">Legal</span>
        </h1>
        <p>Mouse over to interact. Access to justice for everyone.</p>
        <a href="#" class="cta-button">Enter Hub</a>
      </div>
    </div>

    <style is:global>
      :root {
        --bg: #741b25;
        --fg: #ffffff;
        --muted: rgba(255, 255, 255, 0.8);
      }

      body {
        margin: 0;
        height: 100vh;
        background: var(--bg);
        overflow: hidden;
        font-family: "Space Grotesk", sans-serif;
      }

      .stage {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      .hero {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        z-index: 10;
        pointer-events: none;
        padding: 20px;
      }

      .hero h1 {
        margin: 0 0 16px;
        font-weight: 700;
        font-size: 80px;
        line-height: 0.9;
        letter-spacing: -0.04em;
      }

      .hero p {
        margin: 0;
        font-size: 20px;
        color: var(--muted);
        font-weight: 400;
        max-width: 500px;
        line-height: 1.5;
      }

      .cta-button {
        margin-top: 30px;
        pointer-events: auto;
        background: white;
        color: #741b25;
        padding: 12px 30px;
        border-radius: 50px;
        font-weight: bold;
        text-decoration: none;
        transition: transform 0.2s;
      }
      .cta-button:hover {
        transform: scale(1.05);
      }

      .icon-wrap {
        position: absolute;
        width: 60px;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        will-change: transform;
        z-index: 1;
        animation: floaty 6s ease-in-out infinite alternate;
      }

      .icon-wrap:nth-child(odd) {
        animation-duration: 7s;
      }
      .icon-wrap:nth-child(even) {
        animation-duration: 8s;
      }

      .icon-svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 10px 10px rgba(0, 0, 0, 0.2));
      }

      @keyframes floaty {
        0% {
          transform: translateY(0px) rotate(0deg);
        }
        100% {
          transform: translateY(-15px) rotate(5deg);
        }
      }

      .vignette {
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: radial-gradient(
          circle at center,
          transparent 20%,
          rgba(0, 0, 0, 0.4) 100%
        );
        z-index: 0;
      }
    </style>

    <script>
      interface Particle {
        el: HTMLElement;
        homeX: number;
        homeY: number;
        x: number;
        y: number;
        vx: number;
        vy: number;
      }

      const COUNT = 20;
      const ICON_SPACING = 120;
      const MASS = 4.5;
      const SPRING_K = 0.008;
      const DAMPING = 0.96;
      const MOUSE_RADIUS = 180;
      const MOUSE_STRENGTH = 0.3;
      const ZONE_RX = 380;
      const ZONE_RY = 180;

      const stage = document.getElementById("stage");
      const items: Particle[] = [];
      const mouse = { x: -9999, y: -9999 };

      const paths: string[] = [
        "M16 2l14 8v16l-14 8L2 26V10L16 2z",
        "M16 0 A16 16 0 1 0 16 32 A16 16 0 1 0 16 0 Z",
        "M16 2 L30 30 L2 30 Z",
        "M4 4 H28 V28 H4 Z",
        "M12 0h8v12h12v8h-12v12h-8v-12h-12v-8h12z",
      ];

      const colors: string[] = ["#eaddf7", "#cde4fd", "#ffffff", "#9c2331"];

      const rand = (a: number, b: number) => a + Math.random() * (b - a);
      const pick = (arr: string[]) =>
        arr[Math.floor(Math.random() * arr.length)];

      function isInsideOval(
        x: number,
        y: number,
        cx: number,
        cy: number,
        rx: number,
        ry: number
      ) {
        const dx = x - cx;
        const dy = y - cy;
        return (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) <= 1;
      }

      function createIcons() {
        if (!stage) return;

        const rect = stage.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;

        stage.querySelectorAll(".icon-wrap").forEach((el) => el.remove());
        items.length = 0;

        for (let i = 0; i < COUNT; i++) {
          const wrap = document.createElement("div");
          wrap.className = "icon-wrap";

          const ns = "http://www.w3.org/2000/svg";
          const svg = document.createElementNS(ns, "svg");
          svg.setAttribute("viewBox", "0 0 32 32");
          svg.classList.add("icon-svg");

          const path = document.createElementNS(ns, "path");
          path.setAttribute("d", pick(paths));
          path.setAttribute("fill", pick(colors));

          wrap.style.opacity = rand(0.4, 0.9).toString();
          wrap.style.transform = `rotate(${rand(-20, 20)}deg)`;

          svg.appendChild(path);
          wrap.appendChild(svg);
          stage.appendChild(wrap);

          let homeX = 0,
            homeY = 0,
            valid = false;
          let attempts = 0;
          let currentSpacing = ICON_SPACING;

          while (!valid && attempts < 500) {
            const padding = 60;
            homeX = rand(padding, rect.width - padding);
            homeY = rand(padding, rect.height - padding);

            const inZone = isInsideOval(
              homeX,
              homeY,
              cx,
              cy,
              ZONE_RX + 50,
              ZONE_RY + 50
            );

            if (!inZone) {
              let tooClose = false;
              for (const other of items) {
                const dist = Math.hypot(
                  homeX - other.homeX,
                  homeY - other.homeY
                );
                if (dist < currentSpacing) {
                  tooClose = true;
                  break;
                }
              }
              if (!tooClose) valid = true;
            }

            attempts++;
            if (attempts > 200) currentSpacing = ICON_SPACING * 0.8;
            if (attempts > 350) currentSpacing = ICON_SPACING * 0.6;
          }

          items.push({
            el: wrap as HTMLElement,
            homeX: valid ? homeX : cx,
            homeY: valid ? homeY : cy,
            x: valid ? homeX : cx,
            y: valid ? homeY : cy,
            vx: 0,
            vy: 0,
          });
        }
      }

      window.addEventListener("mousemove", (e) => {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
      });

      let resizeTimer: number | undefined;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        // @ts-ignore
        resizeTimer = setTimeout(createIcons, 200);
      });

      function tick() {
        if (!stage) return;
        const rect = stage.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;

        for (const p of items) {
          let targetX = p.homeX;
          let targetY = p.homeY;

          const dx = p.x - mouse.x;
          const dy = p.y - mouse.y;
          const dist = Math.hypot(dx, dy);

          if (dist < MOUSE_RADIUS) {
            const power =
              (1 - dist / MOUSE_RADIUS) * MOUSE_RADIUS * MOUSE_STRENGTH;
            const angle = Math.atan2(dy, dx);
            targetX += Math.cos(angle) * power;
            targetY += Math.sin(angle) * power;
          }

          const dxo = p.x - cx;
          const dyo = p.y - cy;
          const scaleY = ZONE_RX / ZONE_RY;
          const scaledDy = dyo * scaleY;
          const distOval = Math.hypot(dxo, scaledDy);

          if (distOval < ZONE_RX) {
            const overlap = ZONE_RX - distOval;
            let nx = dxo / distOval;
            let ny = scaledDy / distOval;
            ny /= scaleY;

            const pushFactor = overlap * 1.5;
            targetX += nx * pushFactor;
            targetY += ny * pushFactor;
          }

          const ax = (targetX - p.x) * SPRING_K;
          const ay = (targetY - p.y) * SPRING_K;

          p.vx += ax / MASS;
          p.vy += ay / MASS;
          p.vx *= DAMPING;
          p.vy *= DAMPING;
          p.x += p.vx;
          p.y += p.vy;

          if (p.el) {
            p.el.style.left = p.x + "px";
            p.el.style.top = p.y + "px";
            p.el.style.transform = `translate(-50%, -50%)`;
          }
        }
        requestAnimationFrame(tick);
      }

      createIcons();
      requestAnimationFrame(tick);
    </script>
  </body>
</html>
